# Cumulus Usage Guide
Basic how-to's for using the Muon engine abstractions for DX12.

## Core Files and Classes
`Game.h/cpp` Holds the main application which ties everything together. Directs the initialization, usage, timing, destruction, and more of core app resources, such as the `DXCore`, `ResourceCodex`, and render/compute `Pass`.

`DXCore.h/cpp` The DirectX 12 core. Logic for creation of the core DX12 resources, such as the device, command lists, command queues, swap chain, etc. They are just held as global smart pointers (ComPtr) with their creation/destruction guided by `InitDX12` and `DestroyDX12`.

`Pass.h/cpp` Holds the shader resource information about a 'pass' through the API pipeline.

Initializing a pass:

1. Declare the pass variable and give it a name.
2. Set the pass' shader pointers. ie: `SetVertexShader`
3. Call `Generate()`. This will gather the resources described in the shader and use it to generate the pipeline state and root signature. This will fail if shaders are unset.
4. The pass now knows where resources must be bound for its generated root signature. 

Executing a pass:

1. Call `Pass::Bind`, passing in the command list.
2. Bind shader-specific resources (See _Binding Resources_)
3. Submit draw calls or dispatches to the command list as desired. 

`ResourceCodex.h/cpp` Huge collection of maps to organize all of the application's resources. Meshes, Textures, Shaders, Materials, things like that. See _Querying the Codex_).


## Resource Creation
When the application starts, the `Game` calls `ResourceCodex::Init`. This creates a singleton instance of the codex and loads all of the resources automatically from your filesystem's Assets directory. 

* If it exists in the folder (ie: `Assets/Textures`), the game **will** try to load it.
* Shaders must be in the form `shadername.shadertype.hlsl`, ie: `Phong.vs.hlsl`. This shadertype is important as it is how the Shaders VisualStudio project determines how to compile the shader, and how the Application determines how to initialize and store that shader binary.
* Mesh loading is in a bit of a rough state and could use some work. 
  * All meshes assume Phong.vs's description upon auto loading in. Since it's the most detailed one. 
  * In general, `AddMeshFromFile` depends on a `VertexBufferDescription` to decide how to structure the VBO. This description is autogenerated for each shader.
  * One idea for improvement is to just lazily initialize meshes as the codex is queried for them rather than autoloading them at app start. This leaves it up to the user what vertex description is necessary for their purpose. 

## Resource Binding
Shader resources are the 'slots' that we can attach data to. These are all known by the `Pass` automatically and the relevant Root Index can be queried for by name: `int32_t cameraRootIdx = mOpaquePass.GetResourceRootIndex("VSCamera");`.

Using this root index, the user can bind a buffer to it. Broadly speaking DirectX 12 has three main types here: 

* Constant Buffer View (CBV): These are your general use "uniforms" like your camera matrices. Read-only by the shader.

* Shader Resource View (SRV): Read-only buffers like textures. Generally speaking it is a Texture2D in the shader.

* Unordered Access View (UAV): Read-write buffers. A common use is by compute shaders as output, and are generally a RWTexture2D<type> in the shader.

There is too much to be described about the intricacies of binding with these, but basically once you have a root param index, you can call the right flavor of 
`SetGraphicsRootConstantBufferView` / `SetComputeRootConstantBufferView` and bind the texture to it using the GPU Handle (from the texture view) or the GPU Virtual Address (from the resource). 

## Examples

### How to create and bind a new constant buffer. 
1. Create an `UploadBuffer` or `DefaultBuffer`, and then call `Create()` to give it a name and size.
    * Which one is picked matters. `UploadBuffers` are fast to write to from the CPU, but slow to read from the GPU. Good example: Camera view/proj matrices which change a lot frame-to-frame.
    * `DefaultBuffers` are slow and difficult to bind to from the CPU but are very fast to read from the GPU. They are "populate and forget". An example is Material Parameters which don't change, or Textures Resources. 
2. Call `Map()` to get a pointer to copy data to, then memcpy whatever you want to that ptr. Make sure to call `Unmap()` right after.
3. To bind it, first get the relevant root index from the `Pass`, specifying the name of the shader variable. Then call `pCommandList->SetGraphicsRootConstantBufferView`, passing in the root index
    * For either buffer type, the second parameter is from `GetGPUVirtualAddress`

### Creating and binding textures
TODO...